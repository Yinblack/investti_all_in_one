import {
  connect_default
} from "./chunk-PIKQGLLZ.js";
import {
  require_classnames
} from "./chunk-I33YV5XJ.js";
import "./chunk-CXJOIMMF.js";
import "./chunk-4XO5KN4N.js";
import {
  require_prop_types
} from "./chunk-W6MFH5W7.js";
import "./chunk-M2EYFJVX.js";
import "./chunk-OIFOKX25.js";
import {
  require_react
} from "./chunk-4UQS7KPA.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-2GTGKKMZ.js";

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE2(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter2, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE2(fn, context || emitter2, once), evt = prefix ? prefix + event : event;
      if (!emitter2._events[evt])
        emitter2._events[evt] = listener, emitter2._eventsCount++;
      else if (!emitter2._events[evt].fn)
        emitter2._events[evt].push(listener);
      else
        emitter2._events[evt] = [emitter2._events[evt], listener];
      return emitter2;
    }
    function clearEvent(emitter2, evt) {
      if (--emitter2._eventsCount === 0)
        emitter2._events = new Events();
      else
        delete emitter2._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/react-redux-toastr/src/ReduxToastr.jsx
var import_react7 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
var import_classnames3 = __toESM(require_classnames());

// node_modules/react-redux-toastr/src/ToastrBox.jsx
var import_react4 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
var import_classnames2 = __toESM(require_classnames());

// node_modules/react-redux-toastr/src/ProgressBar.jsx
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var ProgressBar = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.state = { percent: 100 };
    this.intervalId = null;
  }
  componentDidMount() {
    const distance = 100 / (this.props.duration / 10);
    this.intervalId = setInterval(() => {
      const percent = this.state.percent - distance;
      this.setState({ percent: percent > 0 ? percent : 0 });
    }, 10);
  }
  componentDidUpdate() {
    if (this.state.percent <= 0 && this.intervalId) {
      clearTimeout(this.intervalId);
    }
  }
  componentWillUnmount() {
    if (this.intervalId) {
      clearTimeout(this.intervalId);
    }
  }
  render() {
    const { percent } = this.state;
    return import_react.default.createElement("div", { className: "rrt-progress-container" }, import_react.default.createElement("div", { className: "rrt-progressbar", style: { width: `${percent}%` } }));
  }
};
__publicField(ProgressBar, "displayName", "ProgressBar");
__publicField(ProgressBar, "propTypes", {
  duration: import_prop_types.default.number.isRequired
});

// node_modules/react-redux-toastr/src/Icon.jsx
var import_react3 = __toESM(require_react());
var import_classnames = __toESM(require_classnames());

// node_modules/react-redux-toastr/src/icons.jsx
var import_react2 = __toESM(require_react());
function icons_default(name) {
  switch (name) {
    case "success":
      return import_react2.default.createElement("g", null, import_react2.default.createElement("path", { d: "M27 4l-15 15-7-7-5 5 12 12 20-20z" }));
    case "info":
      return import_react2.default.createElement("g", null, import_react2.default.createElement("path", { d: "M14 9.5c0-0.825 0.675-1.5 1.5-1.5h1c0.825 0 1.5 0.675 1.5 1.5v1c0 0.825-0.675 1.5-1.5 1.5h-1c-0.825 0-1.5-0.675-1.5-1.5v-1z" }), import_react2.default.createElement("path", { d: "M20 24h-8v-2h2v-6h-2v-2h6v8h2z" }), import_react2.default.createElement("path", { d: "M16 0c-8.837 0-16 7.163-16 16s7.163 16 16 16 16-7.163 16-16-7.163-16-16-16zM16 29c-7.18 0-13-5.82-13-13s5.82-13 13-13 13 5.82 13 13-5.82 13-13 13z" }));
    case "warning":
      return import_react2.default.createElement("g", null, import_react2.default.createElement("path", { d: "M16 2.899l13.409 26.726h-26.819l13.409-26.726zM16 0c-0.69 0-1.379 0.465-1.903 1.395l-13.659 27.222c-1.046 1.86-0.156 3.383 1.978 3.383h27.166c2.134 0 3.025-1.522 1.978-3.383h0l-13.659-27.222c-0.523-0.93-1.213-1.395-1.903-1.395v0z" }), import_react2.default.createElement("path", { d: "M18 26c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z" }), import_react2.default.createElement("path", { d: "M16 22c-1.105 0-2-0.895-2-2v-6c0-1.105 0.895-2 2-2s2 0.895 2 2v6c0 1.105-0.895 2-2 2z" }));
    case "error":
      return import_react2.default.createElement("g", null, import_react2.default.createElement("path", { d: "M12,0C5.373,0,0,5.373,0,12s5.373,12,12,12s12-5.373,12-12S18.627,0,12,0z M12,19.66 c-0.938,0-1.58-0.723-1.58-1.66c0-0.964,0.669-1.66,1.58-1.66c0.963,0,1.58,0.696,1.58,1.66C13.58,18.938,12.963,19.66,12,19.66z M12.622,13.321c-0.239,0.815-0.992,0.829-1.243,0c-0.289-0.956-1.316-4.585-1.316-6.942c0-3.11,3.891-3.125,3.891,0 C13.953,8.75,12.871,12.473,12.622,13.321z" }));
    default:
      return null;
  }
}

// node_modules/react-redux-toastr/src/Icon.jsx
var Icon = class extends import_react3.default.Component {
  render() {
    const { size } = this.props;
    const styles = {
      width: size,
      height: size
    };
    return import_react3.default.createElement(
      "svg",
      {
        className: (0, import_classnames.default)(this.props.className, "toastr-icon"),
        xmlns: "http://www.w3.org/2000/svg",
        preserveAspectRatio: "xMidYMid meet",
        viewBox: `0 0 ${this.props.size} ${this.props.size}`,
        style: styles
      },
      icons_default(this.props.name)
    );
  }
};
__publicField(Icon, "displayName", "ReduxToastrIcon");
__publicField(Icon, "defaultProps", {
  size: 32
});

// node_modules/react-redux-toastr/src/config.js
var toastr = {
  maxAnimationDelay: 6e3,
  newestOnTop: true,
  position: "top-right",
  preventDuplicates: true
};
var config_default = toastr;

// node_modules/react-redux-toastr/src/utils.js
function whichAnimationEvent() {
  let t;
  const el = document.createElement("fakeelement");
  const transitions = {
    animation: "animationend",
    oanimation: "oanimationend",
    MSAnimation: "MSAnimationEnd",
    webkitAnimation: "webkitAnimationEnd"
  };
  for (t in transitions) {
    if (el.style[t] !== void 0) {
      return transitions[t];
    }
  }
}
function createNewEvent(eventName) {
  var event;
  if (typeof Event === "function") {
    event = new Event(eventName);
  } else {
    event = document.createEvent("Event");
    event.initEvent(eventName, true, true);
  }
  return event;
}
function isString(obj) {
  return typeof obj == "string";
}
function toastrWarn(message) {
  if (false) {
    return null;
  }
  console.warn(`[react-redux-toastr] ${message}`);
}
function createReducer(initialState2, fnMap) {
  return (state = initialState2, { type, payload }) => {
    const handle = fnMap[type];
    return handle ? handle(state, payload) : state;
  };
}
function isBrowser() {
  return typeof window !== "undefined";
}
function keyCode(e) {
  return e.which ? e.which : e.keyCode;
}
function mapToToastrMessage(type, array) {
  const obj = {};
  obj.type = type;
  obj.position = config_default.position;
  obj.options = array.filter((item) => typeof item == "object")[0] || {};
  if (obj.options.hasOwnProperty("position")) {
    obj.position = obj.options.position;
  }
  if (!obj.options.hasOwnProperty("removeOnHover")) {
    obj.options.removeOnHover = true;
    if (type === "message") {
      obj.options.removeOnHover = false;
    }
  }
  if (!obj.options.hasOwnProperty("showCloseButton")) {
    obj.options.showCloseButton = true;
  }
  if (type === "message" && !obj.options.hasOwnProperty("timeOut")) {
    obj.options.timeOut = 0;
  }
  if (isString(array[0]) && isString(array[1])) {
    obj.title = array[0];
    obj.message = array[1];
  } else if (isString(array[0]) && !isString(array[1])) {
    obj.title = array[0];
  } else {
    obj.message = array[0];
  }
  return obj;
}
function guid() {
  const r = () => Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  return r() + r() + r() + "-" + r() + "_" + r() + "-" + r() + "_" + r() + r() + r();
}
function onCSSTransitionEnd(node, callback) {
  if (!node) {
    return;
  }
  const animationEnd = whichAnimationEvent();
  const timeoutId = setTimeout(function() {
    const e = createNewEvent(animationEnd);
    toastrWarn("The toastr box was closed automatically, please check 'transitionOut' prop value");
    node.dispatchEvent(e);
  }, config_default.maxAnimationDelay);
  const runOnce = (e) => {
    clearTimeout(timeoutId);
    e.stopPropagation();
    node.removeEventListener(animationEnd, runOnce);
    callback && callback(e);
  };
  node.addEventListener(animationEnd, runOnce);
}
function preventDuplication(currentData, newObjec) {
  let hasDuplication = false;
  currentData.forEach((item) => {
    if (item.options && item.options.preventDuplicates === false)
      return;
    if (item.title === newObjec.title && item.message === newObjec.message && item.type === newObjec.type) {
      hasDuplication = true;
    }
  });
  return hasDuplication;
}
function updateConfig(obj) {
  Object.keys(config_default).forEach(function(key) {
    if (obj.hasOwnProperty(key)) {
      config_default[key] = obj[key];
    }
  });
}
function _bind(strinOrAray, scope) {
  let array = strinOrAray;
  if (!Array.isArray(strinOrAray)) {
    array = strinOrAray.split(" ");
  }
  return array.map((item) => scope[item] = scope[item].bind(scope));
}

// node_modules/react-redux-toastr/src/ToastrBox.jsx
var ToastrBox = class extends import_react4.default.Component {
  constructor(props) {
    super(props);
    __publicField(this, "handlePressEnterOrSpaceKeyToastr", (e) => {
      if (e.key === " " || e.key === "Enter") {
        this.handleClickToastr(e);
      }
    });
    __publicField(this, "handlePressEnterOrSpaceKeyCloseButton", (e) => {
      if (e.key === " " || e.key === "Enter") {
        this.handleClickCloseButton(e);
      }
    });
    __publicField(this, "handleClickToastr", () => {
      let { onToastrClick, closeOnToastrClick } = this.props.item.options;
      this.ignoreIsHiding = true;
      if (onToastrClick) {
        onToastrClick();
      }
      if (closeOnToastrClick) {
        this._setShouldClose(true);
        this._removeToastr();
      }
    });
    __publicField(this, "handleClickCloseButton", (e) => {
      let { onCloseButtonClick } = this.props.item.options;
      e.stopPropagation();
      this.ignoreIsHiding = true;
      if (onCloseButtonClick) {
        onCloseButtonClick();
      }
      this._setShouldClose(true);
      this._removeToastr();
    });
    __publicField(this, "mouseEnter", () => {
      const { removeOnHover } = this.props.item.options;
      if (!removeOnHover && this.intervalId)
        return;
      clearTimeout(this.intervalId);
      this._setIntervalId(null);
      this._setIsHiding(false);
      const { progressBar } = this.props.item.options;
      const timeOut = this._getItemTimeOut();
      if (timeOut && progressBar) {
        this.setState({ progressBar: null });
      }
    });
    __publicField(this, "mouseLeave", () => {
      const { removeOnHover, removeOnHoverTimeOut } = this.props.item.options;
      if (!this.isHiding && (removeOnHover || this.shouldClose)) {
        const interval = removeOnHover === true ? removeOnHoverTimeOut || 1e3 : removeOnHover;
        this._setIntervalId(setTimeout(this._removeToastr, interval));
        const { progressBar } = this.props.item.options;
        const timeOut = this._getItemTimeOut();
        if (timeOut && progressBar) {
          this.setState({ progressBar: { duration: interval } });
        }
      }
    });
    let {
      transitionIn,
      transitionOut
    } = props.item.options;
    this.isHiding = false;
    this.shouldClose = false;
    this.intervalId = null;
    this.ignoreIsHiding = false;
    this.transitionIn = transitionIn || this.props.transitionIn;
    this.transitionOut = transitionOut || this.props.transitionOut;
    this.id = props.item.a11yId || Math.floor(Math.random() * 9999);
    this.state = { progressBar: null };
    _bind(
      [
        "renderSubComponent",
        "renderIcon",
        "renderToastr",
        "renderCloseButton",
        "renderMessage",
        "_onAnimationComplete",
        "_removeToastr",
        "_setTransition",
        "_clearTransition",
        "_setIntervalId",
        "_setIsHiding",
        "_setShouldClose"
      ],
      this
    );
  }
  componentDidMount() {
    const { item } = this.props;
    if (this.props.inMemory[item.id])
      return;
    const timeOut = this._getItemTimeOut();
    if (timeOut) {
      this._setIntervalId(setTimeout(this._removeToastr, timeOut));
    }
    if (timeOut && item.options.progressBar) {
      this.setState({ progressBar: { duration: this._getItemTimeOut() } });
    }
    this._setTransition();
    if (this.toastrBoxElement) {
      this.toastrBoxElement.addEventListener("transitionend", this._onAnimationComplete);
    }
    this.props.addToMemory(item.id);
    if (this.closeButton !== void 0 && !item.options.disableCloseButtonFocus) {
      this.closeButton.focus();
    }
  }
  componentWillUnmount() {
    if (this.intervalId) {
      clearTimeout(this.intervalId);
    }
    if (this.toastrBoxElement) {
      this.toastrBoxElement.removeEventListener("transitionend", this._onAnimationComplete);
    }
    setTimeout(function() {
      const toastrControls = document.querySelectorAll(".toastr-control:not(.disable-auto-focus)");
      if (toastrControls.length) {
        toastrControls[0].focus();
      }
    }, 50);
  }
  get isToastrClickable() {
    const { onToastrClick, closeOnToastrClick } = this.props.item.options;
    const hasOnToastrClick = !!onToastrClick;
    return hasOnToastrClick || closeOnToastrClick;
  }
  renderSubComponent() {
    const {
      id,
      options
    } = this.props.item;
    const removeCurrentToastrFunc = () => this.props.remove(id);
    if ((0, import_react4.isValidElement)(options.component)) {
      return import_react4.default.cloneElement(options.component, {
        remove: removeCurrentToastrFunc
      });
    }
    return import_react4.default.createElement(options.component, { remove: removeCurrentToastrFunc });
  }
  renderIcon() {
    const {
      type,
      options
    } = this.props.item;
    if ((0, import_react4.isValidElement)(options.icon)) {
      return import_react4.default.cloneElement(options.icon);
    }
    const iconName = type === "light" ? options.icon : type;
    return import_react4.default.createElement(Icon, { name: iconName });
  }
  renderCloseButton() {
    let closeButtonAttributes = {
      tabIndex: 0,
      role: "button",
      onKeyPress: this.handlePressEnterOrSpaceKeyCloseButton
    };
    if (this.isToastrClickable) {
      closeButtonAttributes = {};
    }
    return import_react4.default.createElement(
      "div",
      {
        className: (0, import_classnames2.default)("close-toastr", "toastr-control", {
          "disable-auto-focus": this.props.item.options.disableCloseButtonFocus
        }),
        "aria-label": "toast",
        onClick: this.handleClickCloseButton,
        ref: (ref) => this.closeButton = ref,
        ...closeButtonAttributes
      },
      import_react4.default.createElement("span", null, "✕")
    );
  }
  renderToastr() {
    const {
      type,
      options,
      message,
      title
    } = this.props.item;
    const ariaAttributes = {};
    if (title) {
      ariaAttributes["aria-labelledby"] = `dialogTitle-${this.id}`;
    }
    if (message) {
      ariaAttributes["aria-describedby"] = `dialogDesc-${this.id}`;
    }
    return import_react4.default.createElement("div", null, import_react4.default.createElement("div", { className: "rrt-left-container" }, import_react4.default.createElement("div", { className: "rrt-holder" }, this.renderIcon())), options.status && type === "light" && import_react4.default.createElement("div", { className: (0, import_classnames2.default)("toastr-status", options.status) }), import_react4.default.createElement("div", { className: "rrt-middle-container", role: "alertdialog", ...ariaAttributes }, title && import_react4.default.createElement("div", { id: `dialogTitle-${this.id}`, className: "rrt-title" }, title), message && import_react4.default.createElement("div", { id: `dialogDesc-${this.id}`, className: "rrt-text" }, message), options.component && this.renderSubComponent()), import_react4.default.createElement("div", { className: "rrt-right-container" }, options.showCloseButton && this.renderCloseButton()), this.state.progressBar ? import_react4.default.createElement(ProgressBar, { ...this.state.progressBar }) : null);
  }
  renderMessage() {
    const {
      title,
      message,
      options
    } = this.props.item;
    return import_react4.default.createElement("div", null, import_react4.default.createElement("div", { className: "rrt-title" }, title, this.renderCloseButton()), import_react4.default.createElement("div", { className: "rrt-text" }, message, options.component && this.renderSubComponent()));
  }
  toastr() {
    if (this.props.item.type === "message") {
      return this.renderMessage();
    }
    return this.renderToastr();
  }
  _getItemTimeOut() {
    const { item } = this.props;
    let { timeOut } = item.options;
    if (typeof timeOut === "undefined") {
      timeOut = this.props.timeOut;
    }
    return timeOut;
  }
  _onAnimationComplete() {
    const { remove: remove2, item } = this.props;
    const { options, id } = item;
    if (this.isHiding || this.ignoreIsHiding) {
      this._setIsHiding(false);
      this.ignoreIsHiding = false;
      remove2(id);
      if (options.onHideComplete) {
        options.onHideComplete();
      }
    } else if (!this.isHiding && options.onShowComplete) {
      options.onShowComplete();
    }
  }
  _removeToastr() {
    if (!this.isHiding) {
      this._setIsHiding(true);
      this._setTransition(true, false);
      onCSSTransitionEnd(this.toastrBoxElement, this._onAnimationComplete);
    }
  }
  _setTransition(hide, autoRemove = true) {
    const animationType = hide ? this.transitionOut : this.transitionIn;
    const onEndListener = (e) => {
      if (e && e.target == this.toastrBoxElement) {
        this.toastrBoxElement.classList.remove(animationType);
      }
    };
    if (this.toastrBoxElement) {
      if (autoRemove) {
        onCSSTransitionEnd(this.toastrBoxElement, onEndListener);
      }
      this.toastrBoxElement.classList.add(animationType);
    }
  }
  _clearTransition() {
    if (this.toastrBoxElement) {
      this.toastrBoxElement.classList.remove(this.transitionIn, this.transitionOut);
    }
  }
  _setIntervalId(intervalId) {
    this.intervalId = intervalId;
  }
  _setIsHiding(val) {
    this.isHiding = val;
  }
  _setShouldClose(val) {
    this.shouldClose = val;
  }
  render() {
    const {
      options,
      type
    } = this.props.item;
    let toastrClickAttributes = {};
    if (this.isToastrClickable) {
      toastrClickAttributes.role = "button";
      toastrClickAttributes.tabIndex = 0;
      toastrClickAttributes.onClick = this.handleClickToastr;
      toastrClickAttributes.onKeyPress = this.handlePressEnterOrSpaceKeyToastr;
    }
    return import_react4.default.createElement(
      "div",
      {
        ref: (ref) => this.toastrBoxElement = ref,
        className: (0, import_classnames2.default)(
          "toastr",
          "animated",
          "rrt-" + type,
          options.className
        ),
        onMouseEnter: this.mouseEnter,
        onMouseLeave: this.mouseLeave,
        ...toastrClickAttributes
      },
      this.toastr()
    );
  }
};
__publicField(ToastrBox, "displayName", "ToastrBox");
__publicField(ToastrBox, "propTypes", {
  item: import_prop_types2.default.shape({
    options: import_prop_types2.default.shape({
      transitionIn: import_prop_types2.default.string,
      transitionOut: import_prop_types2.default.string
    })
  })
});

// node_modules/react-redux-toastr/src/ToastrConfirm.jsx
var import_react6 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/react-redux-toastr/src/Button.jsx
var import_react5 = __toESM(require_react());
var Button = (props) => import_react5.default.createElement("button", { type: "button", onClick: () => props.onClick(), className: "rrt-button " + props.className, ref: props.innerRef }, props.children);
Button.displayName = "ReduxConfirmButton";
var Button_default = Button;

// node_modules/react-redux-toastr/src/ToastrConfirm.jsx
var ENTER = 13;
var ESC = 27;
var ToastrConfirm = class extends import_react6.default.Component {
  constructor(props) {
    super(props);
    const {
      confirmOptions,
      confirm
    } = this.props;
    const {
      okText,
      cancelText,
      transitionIn,
      transitionOut,
      disableCancel,
      closeOnShadowClick
    } = confirm.options;
    this.okText = okText || confirmOptions.okText;
    this.cancelText = cancelText || confirmOptions.cancelText;
    this.transitionIn = transitionIn || confirmOptions.transitionIn || props.transitionIn;
    this.transitionOut = transitionOut || confirmOptions.transitionOut || props.transitionOut;
    this.disableCancel = disableCancel || confirmOptions.disableCancel;
    this.closeOnShadowClick = closeOnShadowClick || confirmOptions.closeOnShadowClick;
    _bind("setTransition removeConfirm handleOnKeyUp handleOnKeyDown handleCloseOnShadowClick", this);
    this.isKeyDown = false;
    this.id = Math.floor(Math.random() * 9999);
  }
  componentDidMount() {
    this.isHiding = false;
    this.hasClicked = false;
    this.confirmHolderElement.focus();
    if (this.props.confirm.show) {
      this.setTransition(true);
    }
    if (this.closeButton !== void 0 && this.closeButton.focus !== void 0) {
      this.closeButton.focus();
    }
  }
  componentWillUnmount() {
    setTimeout(function() {
      if (document.getElementsByClassName("toastr-control").length > 0) {
        document.getElementsByClassName("toastr-control")[0].focus();
      }
    }, 50);
  }
  handleOnKeyDown(e) {
    if (keyCode(e) == ENTER) {
      e.preventDefault();
    }
    this.isKeyDown = true;
  }
  handleCloseOnShadowClick(_e) {
    if (this.closeOnShadowClick) {
      this.handleCancelClick();
    }
  }
  handleButtonClick(callback) {
    if (this.hasClicked)
      return;
    this.hasClicked = true;
    const onAnimationEnd = () => {
      this.removeConfirm();
      if (callback) {
        callback();
      }
    };
    this.setTransition();
    onCSSTransitionEnd(this.confirmElement, onAnimationEnd);
  }
  handleConfirmClick() {
    const callback = this.props.confirm.options ? this.props.confirm.options.onOk : null;
    this.handleButtonClick(callback);
  }
  handleCancelClick() {
    const callback = this.props.confirm.options ? this.props.confirm.options.onCancel : null;
    this.handleButtonClick(callback);
  }
  setTransition(add2) {
    if (add2) {
      this.isHiding = false;
      this.confirmElement.classList.add(this.transitionIn);
      if (isBrowser())
        return document.querySelector("body").classList.add("toastr-confirm-active");
    }
    this.isHiding = true;
    this.confirmElement.classList.remove(this.transitionIn);
    this.confirmElement.classList.add(this.transitionOut);
  }
  removeConfirm() {
    this.isHiding = false;
    this.props.hideConfirm();
    if (isBrowser())
      return document.querySelector("body").classList.remove("toastr-confirm-active");
  }
  handleOnKeyUp(e) {
    const code = keyCode(e);
    if (code == ESC && !this.disableCancel) {
      this.handleCancelClick();
    } else if (code == ESC && this.disableCancel) {
      this.handleConfirmClick();
    } else if (code == ENTER && this.isKeyDown) {
      this.isKeyDown = false;
      this.handleConfirmClick();
    }
  }
  containsOkButton(buttons) {
    return buttons && buttons.filter((button) => button.ok === true).length > 0;
  }
  containsCancelButton(buttons) {
    return buttons && buttons.filter((button) => button.cancel === true).length > 0;
  }
  getCustomButtonHandler(config) {
    if (config.ok === true) {
      return this.handleConfirmClick.bind(this);
    }
    if (config.cancel === true) {
      return this.handleCancelClick.bind(this);
    }
    return () => this.handleButtonClick(config.handler);
  }
  getCustomButtonText(config) {
    if (config.ok === true) {
      return this.okText;
    }
    if (config.cancel === true) {
      return this.cancelText;
    }
    return config.text;
  }
  getCustomButtonClassName(config) {
    if (config.ok === true) {
      return "rrt-ok-btn";
    }
    if (config.cancel === true) {
      return "rrt-cancel-btn";
    }
    return config.className;
  }
  render() {
    const {
      options,
      message
    } = this.props.confirm;
    const wrapperProps = {};
    options.id && (wrapperProps.id = options.id);
    return import_react6.default.createElement(
      "div",
      {
        className: "rrt-confirm-holder",
        tabIndex: "-1",
        ref: (ref) => this.confirmHolderElement = ref,
        onKeyDown: this.handleOnKeyDown,
        onKeyUp: this.handleOnKeyUp,
        role: "alert",
        ...wrapperProps
      },
      import_react6.default.createElement("div", { className: "rrt-confirm animated", ref: (ref) => this.confirmElement = ref, role: "alertdialog", "aria-describedby": `dialogDesc-${this.id}` }, message && import_react6.default.createElement("div", { className: "rrt-message", id: `dialogDesc-${this.id}` }, message), options.component && import_react6.default.createElement(options.component, null), import_react6.default.createElement("div", { className: "rrt-buttons-holder" }, !this.containsOkButton(options.buttons) && import_react6.default.createElement(Button_default, { tabIndex: "0", innerRef: (ref) => this.closeButton = ref, className: "rrt-ok-btn toastr-control", onClick: () => this.handleConfirmClick() }, this.okText), !this.disableCancel && !this.containsCancelButton(options.buttons) && import_react6.default.createElement(Button_default, { tabIndex: "0", innerRef: (ref) => this.closeButton = ref, className: "rrt-cancel-btn toastr-control", onClick: this.handleCancelClick.bind(this) }, this.cancelText), options.buttons && options.buttons.map((button, index) => {
        if (button.cancel === true && this.disableCancel) {
          return null;
        }
        const handler = this.getCustomButtonHandler(button);
        const text = this.getCustomButtonText(button);
        const className = this.getCustomButtonClassName(button);
        return import_react6.default.createElement(Button_default, { tabIndex: "0", className, onClick: handler, key: index }, text);
      }))),
      import_react6.default.createElement("div", { className: "shadow", onClick: this.handleCloseOnShadowClick.bind(this) })
    );
  }
};
__publicField(ToastrConfirm, "displayName", "ToastrConfirm");
__publicField(ToastrConfirm, "propTypes", {
  confirm: import_prop_types3.default.shape({
    options: import_prop_types3.default.shape({
      transitionIn: import_prop_types3.default.string,
      transitionOut: import_prop_types3.default.string
    })
  })
});

// node_modules/react-redux-toastr/src/actions.js
var actions_exports = {};
__export(actions_exports, {
  add: () => add,
  clean: () => clean,
  hideConfirm: () => hideConfirm,
  remove: () => remove,
  removeByType: () => removeByType,
  showConfirm: () => showConfirm
});

// node_modules/react-redux-toastr/src/constants.js
var ADD_TOASTR = "@ReduxToastr/toastr/ADD";
var REMOVE_TOASTR = "@ReduxToastr/toastr/REMOVE";
var CLEAN_TOASTR = "@ReduxToastr/toastr/CLEAN";
var SHOW_CONFIRM = "@ReduxToastr/confirm/SHOW";
var HIDE_CONFIRM = "@ReduxToastr/confirm/HIDE";
var REMOVE_BY_TYPE = "@ReduxToastr/toastr/REMOVE_BY_TYPE";
var TRANSITIONS = {
  in: ["bounceIn", "bounceInDown", "fadeIn"],
  out: ["bounceOut", "bounceOutUp", "fadeOut"]
};

// node_modules/react-redux-toastr/src/reducer.js
var toastrsCache = [];
var initialState = {
  toastrs: [],
  confirm: null
};
var reducer_default = createReducer(initialState, {
  [ADD_TOASTR]: (state, toastr3) => {
    if (toastr3.ignoreToastr) {
      return state;
    }
    const newToastr = {
      id: guid(),
      position: config_default.position,
      ...toastr3
    };
    if (!newToastr.a11yId && toastr3 && toastr3.hasOwnProperty("id") && !toastr3.hasOwnProperty("a11yId")) {
      newToastr.a11yId = toastr3.id;
    }
    let newState = {};
    if (!config_default.newestOnTop) {
      newState = {
        ...state,
        toastrs: [
          ...state.toastrs,
          newToastr
        ]
      };
    } else {
      newState = {
        ...state,
        toastrs: [
          newToastr,
          ...state.toastrs
        ]
      };
    }
    toastrsCache = newState.toastrs;
    return newState;
  },
  [REMOVE_TOASTR]: (state, id) => {
    let newState = {
      ...state,
      toastrs: state.toastrs.filter((toastr3) => toastr3.id !== id)
    };
    toastrsCache = newState.toastrs;
    return newState;
  },
  [REMOVE_BY_TYPE]: (state, type) => {
    let newState = {
      ...state,
      toastrs: state.toastrs.filter((toastr3) => toastr3.type !== type)
    };
    toastrsCache = newState.toastrs;
    return newState;
  },
  [CLEAN_TOASTR]: (state) => {
    toastrsCache = [];
    return {
      ...state,
      toastrs: []
    };
  },
  [SHOW_CONFIRM]: (state, { id, message, options }) => {
    return {
      ...state,
      confirm: {
        id: id || guid(),
        show: true,
        message,
        options: options || {}
      }
    };
  },
  [HIDE_CONFIRM]: (state) => {
    return {
      ...state,
      confirm: null
    };
  }
});

// node_modules/react-redux-toastr/src/actions.js
function add(toastr3) {
  if (config_default.preventDuplicates && preventDuplication(toastrsCache, toastr3)) {
    return {
      type: ADD_TOASTR,
      payload: {
        ignoreToastr: true
      }
    };
  }
  return {
    type: ADD_TOASTR,
    payload: toastr3
  };
}
var clean = () => ({ type: CLEAN_TOASTR });
var remove = (payload) => ({
  type: REMOVE_TOASTR,
  payload
});
var showConfirm = (payload) => ({
  type: SHOW_CONFIRM,
  payload
});
var hideConfirm = () => ({ type: HIDE_CONFIRM });
var removeByType = (payload) => ({
  type: REMOVE_BY_TYPE,
  payload
});

// node_modules/react-redux-toastr/src/toastrEmitter.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var emitter = new import_eventemitter3.default();
var addToToastr = (type, array) => emitter.emit("add/toastr", mapToToastrMessage(type, array));
var actions = {};
["light", "message", "info", "success", "warning", "error"].forEach((item) => {
  actions[item] = (...args) => addToToastr(item, args);
});
actions.clean = () => emitter.emit("clean/toastr");
actions.removeByType = (type) => emitter.emit("removeByType/toastr", type);
actions.remove = (id) => emitter.emit("remove/toastr", id);
actions.confirm = (...args) => {
  emitter.emit("toastr/confirm", {
    message: args[0],
    options: args[1] || {}
  });
};
var EE = emitter;
var toastrEmitter = actions;

// node_modules/react-redux-toastr/src/ReduxToastr.jsx
var ReduxToastr = class extends import_react7.default.Component {
  constructor(props) {
    super(props);
    __publicField(this, "toastrFired", {});
    __publicField(this, "toastrPositions", [
      "top-left",
      "top-right",
      "top-center",
      "bottom-left",
      "bottom-right",
      "bottom-center"
    ]);
    updateConfig(props);
  }
  componentDidMount() {
    const { add: add2, showConfirm: showConfirm2, clean: clean2, removeByType: removeByType2, remove: remove2 } = this.props;
    EE.on("toastr/confirm", showConfirm2);
    EE.on("add/toastr", add2);
    EE.on("clean/toastr", clean2);
    EE.on("removeByType/toastr", removeByType2);
    EE.on("remove/toastr", remove2);
  }
  componentWillUnmount() {
    EE.removeListener("toastr/confirm");
    EE.removeListener("add/toastr");
    EE.removeListener("clean/toastr");
    EE.removeListener("removeByType/toastr");
    EE.removeListener("remove/toastr");
    this.toastrFired = {};
  }
  _addToMemory(id) {
    this.toastrFired[id] = true;
  }
  _renderToastrForPosition(position) {
    const { toastrs } = this.props.toastr;
    if (toastrs) {
      return toastrs.filter((item) => item.position === position).map((item) => {
        const mergedItem = {
          ...item,
          options: {
            progressBar: this.props.progressBar,
            transitionIn: this.props.transitionIn,
            transitionOut: this.props.transitionOut,
            closeOnToastrClick: this.props.closeOnToastrClick,
            ...item.options
          }
        };
        return import_react7.default.createElement("div", { key: item.id }, import_react7.default.createElement(
          ToastrBox,
          {
            inMemory: this.toastrFired,
            addToMemory: () => this._addToMemory(item.id),
            item: mergedItem,
            ...this.props
          }
        ), item.options && item.options.attention && import_react7.default.createElement(
          "div",
          {
            onClick: () => {
              if (typeof item.options.onAttentionClick === "function") {
                item.options.onAttentionClick(item.id);
              } else {
                this.props.remove(item.id);
              }
            },
            className: "toastr-attention"
          }
        ));
      });
    }
  }
  _renderToastrs() {
    const { toastr: toastr3 } = this.props;
    const width = toastr3.toastrs && toastr3.toastrs[0] && toastr3.toastrs[0].options && toastr3.toastrs[0].options.width;
    const style = width ? { width } : {};
    return import_react7.default.createElement("div", null, this.toastrPositions.map((position) => {
      return import_react7.default.createElement("div", { key: position, className: position, style }, this._renderToastrForPosition(position));
    }));
  }
  render() {
    const { className, toastr: toastr3 } = this.props;
    return import_react7.default.createElement("div", { className: (0, import_classnames3.default)("redux-toastr", className), "aria-live": "assertive" }, toastr3.confirm && import_react7.default.createElement(
      ToastrConfirm,
      {
        confirm: toastr3.confirm,
        ...this.props
      }
    ), this._renderToastrs());
  }
};
__publicField(ReduxToastr, "displayName", "ReduxToastr");
__publicField(ReduxToastr, "propTypes", {
  toastr: import_prop_types4.default.object,
  position: import_prop_types4.default.string,
  newestOnTop: import_prop_types4.default.bool,
  timeOut: import_prop_types4.default.number,
  confirmOptions: import_prop_types4.default.object,
  progressBar: import_prop_types4.default.bool,
  transitionIn: import_prop_types4.default.oneOf(TRANSITIONS.in),
  transitionOut: import_prop_types4.default.oneOf(TRANSITIONS.out),
  preventDuplicates: import_prop_types4.default.bool,
  closeOnToastrClick: import_prop_types4.default.bool
});
__publicField(ReduxToastr, "defaultProps", {
  position: "top-right",
  newestOnTop: true,
  timeOut: 5e3,
  progressBar: false,
  transitionIn: TRANSITIONS.in[0],
  transitionOut: TRANSITIONS.out[0],
  preventDuplicates: false,
  closeOnToastrClick: false,
  getState: (state) => state.toastr,
  confirmOptions: {
    okText: "ok",
    cancelText: "cancel"
  }
});
var ReduxToastr_default = connect_default(
  (state, ownProps) => ({
    toastr: ownProps.getState ? ownProps.getState(state) : state.toastr
  }),
  actions_exports
)(ReduxToastr);

// node_modules/react-redux-toastr/src/index.js
var src_default = ReduxToastr_default;
var actions2 = actions_exports;
var reducer = reducer_default;
var toastr2 = toastrEmitter;
export {
  actions2 as actions,
  src_default as default,
  reducer,
  toastr2 as toastr
};
//# sourceMappingURL=react-redux-toastr.js.map
